#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <conio.h>
#include <stdlib.h>
#include <iostream>

/*			Лабораторная 14
			программа 14_2
Реализовать задачу с использованием другой динамической струк-
туры или придумать свою задачу, написать и отладить для нее программу.
*/




struct Node                             //Структура, являющаяся звеном списка
{
	int x;                             //Значение x будет передаваться в список
	Node *Next, *Prev;                 //Указатели на адреса следующего и предыдущего элементов списка
};

class List                              //Создаем тип данных Список
{
	Node *Head, *Tail;                 //Указатели на адреса начала списка и его конца
public:
	List() :Head(NULL), Tail(NULL) {};    //Инициализируем адреса как пустые
	~List();                           //Прототип деструктора
	void Show();                       //Прототип функции отображения списка на экране
	void Add(int x);                   //Прототип функции добавления элементов в список
};

List::~List()                           //Деструктор
{
	while (Head)                       //Пока по адресу на начало списка что-то есть
	{
		Tail = Head->Next;             //Резервная копия адреса следующего звена списка
		delete Head;                   //Очистка памяти от первого звена
		Head = Tail;                   //Смена адреса начала на адрес следующего элемента
	}
}

void List::Add(int x)
{
	Node *temp = new Node;               //Выделение памяти под новый элемент структуры
	temp->Next = NULL;                   //Указываем, что изначально по следующему адресу пусто
	temp->x = x;                         //Записываем значение в структуру

	if (Head != NULL)                    //Если список не пуст
	{
		temp->Prev = Tail;               //Указываем адрес на предыдущий элемент в соотв. поле
		Tail->Next = temp;               //Указываем адрес следующего за хвостом элемента
		Tail = temp;                     //Меняем адрес хвоста
	}
	else //Если список пустой
	{
		temp->Prev = NULL;               //Предыдущий элемент указывает в пустоту
		Head = Tail = temp;              //Голова=Хвост=тот элемент, что сейчас добавили
	}
}

void List::Show()
{
	//ВЫВОДИМ СПИСОК С КОНЦА
	Node *temp = Tail;                   //Временный указатель на адрес последнего элемента

	while (temp != NULL)               //Пока не встретится пустое значение
	{
		printf("%d ", temp->x);        //Выводить значение на экран
		temp = temp->Prev;             //Указываем, что нужен адрес предыдущего элемента
	}
	printf("\n");

	//ВЫВОДИМ СПИСОК С НАЧАЛА
	temp = Head;                       //Временно указываем на адрес первого элемента
	while (temp != NULL)              //Пока не встретим пустое значение
	{
		printf("%d ",temp->x);        //Выводим каждое считанное значение на экран
		temp = temp->Next;             //Смена адреса на адрес следующего элемента
	}
	printf("\n");
}

int main()
{
	system("CLS");
	List lst; //Объявляем переменную, тип которой есть список
	lst.Add(999); //Добавляем в список элементы
	lst.Add(666);
	lst.Add(6969);
	lst.Add(9696);

	lst.Show(); //Отображаем список на экране
	system("PAUSE");
	return 0;
}